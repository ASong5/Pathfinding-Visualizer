{"version":3,"file":"static/js/565.08279896.chunk.js","mappings":"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","sources":["Grid.js","utils/algorithms.js","utils/webworker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import React, { useEffect, useState, useRef } from \"react\";\nimport Node from \"./Node\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faInfoCircle } from \"@fortawesome/free-solid-svg-icons\";\nimport \"./Grid.css\";\n\nconst path = process.env.PUBLIC_URL;\nconst loadingGif = \"/images/loading.gif\";\n\nconst DEFAULT_GRID_SIZE = 10; // square root of total grid size;\nconst MAX_GRID_SIZE = 50;\nconst ALGOS = { bfs: 0, dfs: 1, dijkstra: 2, aStar: 3 };\nconst ANIMATION_TYPE = { fade: 0, swarm: 1 };\n\nconst algoToString = (algo) => {\n  let algoString = \"\";\n  if (algo === ALGOS.bfs) algoString = \"Breadth-First Search\";\n  else if (algo === ALGOS.dfs) algoString = \"Depth-First Search\";\n  else if (algo === ALGOS.dijkstra) algoString = \"Dijkstra Shortest Path\";\n  else if (algo === ALGOS.aStar) algoString = \"A* Shortest Path\";\n  return algoString;\n};\n\nconst animationTypeToString = (animationType) => {\n  let animationTypeString = \"\";\n  if (animationType === ANIMATION_TYPE.swarm) animationTypeString = \"Swarm\";\n  else if (animationType === ANIMATION_TYPE.fade) animationTypeString = \"Fade\";\n  return animationTypeString;\n};\n\nconst createEmptyGrid = (gridSize) => {\n  const grid = [];\n  for (let row = 0; row < gridSize; row++) {\n    grid.push(\n      Array.from({ length: gridSize }, () => ({\n        isWall: false,\n        isVisited: false,\n        isStart: false,\n        isEnd: false,\n        isShortest: false,\n        weight: 1,\n      }))\n    );\n  }\n  return grid;\n};\n\nconst resizeGrid = (grid, newGridSize) => {\n  const oldGridSize = grid.length;\n  const size = newGridSize > oldGridSize ? oldGridSize : newGridSize;\n  let isStart = false;\n  let isEnd = false;\n\n  let newGrid = createEmptyGrid(newGridSize);\n\n  for (let row = 0; row < size; row++) {\n    for (let col = 0; col < size; col++) {\n      if (grid[row][col].isStart) {\n        newGrid[row][col].isStart = true;\n        isStart = true;\n      } else if (grid[row][col].isEnd) {\n        newGrid[row][col].isEnd = true;\n        isEnd = true;\n      } else if (grid[row][col].isWall) newGrid[row][col].isWall = true;\n\n      newGrid[row][col].weight = grid[row][col].weight;\n    }\n  }\n  return [newGrid, isStart, isEnd];\n};\n\nexport const Grid = React.memo(({ isDarkMode }) => {\n  const [grid, setGrid] = useState(createEmptyGrid(DEFAULT_GRID_SIZE));\n  const [weightValue, setWeightValue] = useState(1);\n  const [isResetDisabled, setIsResetDisabled] = useState(true);\n  const [gridSize, setGridSize] = useState(DEFAULT_GRID_SIZE);\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [startNode, setStartNode] = useState(null);\n  const [endNode, setEndNode] = useState(null);\n  const [visualizationRunning, setVisualizationRunning] = useState(false);\n  const [isComputing, setIsComputing] = useState(false);\n  const [algo, setAlgo] = useState(ALGOS.bfs);\n  const [animationTime, setAnimationTime] = useState(2000);\n  const [animationCount, setAnimationCount] = useState(0);\n  const [animationType, setAnimationType] = useState(ANIMATION_TYPE.fade);\n  const [cachedVisited, setCachedVisited] = useState(\n    Array.from({ length: Object.keys(ALGOS).length }, () => ({\n      visited: [],\n      path: [],\n      failedPrevious: false,\n    }))\n  );\n  const [algoWorker, setAlgoWorker] = useState(null);\n  const gridRef = useRef(null);\n\n  useEffect(() => {\n    document.documentElement.style.setProperty(\n      \"--animationTime\",\n      `${animationTime / 2000}s`\n    );\n\n    const gridContainer = document.querySelector(\".grid-container\");\n    gridContainer.addEventListener(\"animationend\", handleAnimationEnd);\n\n    setAlgoWorker(new Worker(new URL(\"./utils/webworker.js\", import.meta.url)));\n  }, []);\n\n  useEffect(() => {\n    const execShortestPath = async () => {\n      if (algo !== ALGOS.dfs) {\n        if (animationCount === cachedVisited[algo].visited.length - 2) {\n          await visualizeShortestPath(cachedVisited[algo].path);\n          setAnimationCount(0);\n          setVisualizationRunning(false);\n        }\n      }\n    };\n    execShortestPath();\n  }, [animationCount]);\n\n  useEffect(() => {\n    let newGridProps = resizeGrid(grid, gridSize);\n    setGrid(newGridProps[0]);\n    if (!newGridProps[1]) setStartNode(null);\n    if (!newGridProps[2]) setEndNode(null);\n  }, [gridSize]);\n\n  useEffect(() => {\n    if (!visualizationRunning) resetVisualization();\n  }, [visualizationRunning]);\n\n  const handleAnimationEnd = (e) => {\n    if (\n      e.target.classList.contains(\"visited-swarm\") ||\n      e.target.classList.contains(\"visited-fade\")\n    ) {\n      setAnimationCount((prev) => prev + 1);\n    }\n  };\n\n  const handleNodeClick = (row, col, e) => {\n    const newGrid = [...grid];\n    if (e.ctrlKey) {\n      if (\n        !newGrid[row][col].isStart &&\n        !newGrid[row][col].isEnd &&\n        !newGrid[row][col].isWall &&\n        (algo === ALGOS.dijkstra || algo === ALGOS.aStar) &&\n        newGrid[row][col].weight !== weightValue\n      ) {\n        setIsResetDisabled(false);\n        newGrid[row][col].weight = weightValue;\n      }\n    } else if (startNode && endNode) {\n      setIsResetDisabled(false);\n      if (newGrid[row][col].isStart) {\n        newGrid[row][col].isStart = false;\n        setStartNode(null);\n      } else if (newGrid[row][col].isEnd) {\n        newGrid[row][col].isEnd = false;\n        setEndNode(null);\n      } else {\n        newGrid[row][col].isWall = !newGrid[row][col].isWall;\n        if (\n          (algo === ALGOS.dijkstra || algo === ALGOS.aStar) &&\n          newGrid[row][col].weight !== weightValue\n        )\n          newGrid[row][col].weight = weightValue;\n      }\n    } else if (!startNode) {\n      setIsResetDisabled(false);\n      if (newGrid[row][col].isEnd) {\n        newGrid[row][col].isEnd = false;\n        setEndNode(null);\n      } else {\n        newGrid[row][col].isStart = true;\n        newGrid[row][col].isWall = false;\n        if (\n          (algo === ALGOS.dijkstra || algo === ALGOS.aStar) &&\n          newGrid[row][col].weight !== weightValue\n        )\n          newGrid[row][col].weight = weightValue;\n        setStartNode([row, col]);\n      }\n    } else if (!endNode) {\n      setIsResetDisabled(false);\n      if (newGrid[row][col].isStart) {\n        newGrid[row][col].isStart = false;\n        setStartNode(null);\n      } else {\n        newGrid[row][col].isEnd = true;\n        newGrid[row][col].isWall = false;\n        if (\n          (algo === ALGOS.dijkstra || algo === ALGOS.aStar) &&\n          newGrid[row][col].weight !== weightValue\n        )\n          newGrid[row][col].weight = weightValue;\n        setEndNode([row, col]);\n      }\n    }\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n    setGrid(newGrid);\n  };\n\n  const handleNodeDrag = (row, col, e) => {\n    if (isMouseDown) {\n      const newGrid = [...grid];\n      if (\n        (algo === ALGOS.dijkstra || algo === ALGOS.aStar) &&\n        newGrid[row][col].weight !== weightValue\n      )\n        setIsResetDisabled(false);\n      if (e.ctrlKey) {\n        if (\n          !newGrid[row][col].isStart &&\n          !newGrid[row][col].isEnd &&\n          !newGrid[row][col].isWall &&\n          (algo === ALGOS.dijkstra || algo === ALGOS.aStar) &&\n          newGrid[row][col].weight !== weightValue\n        ) {\n          newGrid[row][col].weight = weightValue;\n        }\n      } else if (startNode && endNode) {\n        if (!newGrid[row][col].isStart && !newGrid[row][col].isEnd) {\n          newGrid[row][col].isWall = !newGrid[row][col].isWall;\n          newGrid[row][col].weight = weightValue;\n        }\n      }\n      setCachedVisited(\n        Array.from({ length: Object.keys(ALGOS).length }, () => ({\n          visited: [],\n          path: [],\n          failedPrevious: false,\n        }))\n      );\n      setGrid(newGrid);\n    }\n  };\n\n  const handleMouseDown = () => {\n    setIsMouseDown(true);\n  };\n\n  const handleMouseUp = () => {\n    setIsMouseDown(false);\n  };\n\n  const handleResetGrid = () => {\n    setGrid(createEmptyGrid(gridSize));\n    setIsResetDisabled(true);\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n    setStartNode(null);\n    setEndNode(null);\n  };\n\n  const resetVisualization = () => {\n    const newGrid = [...grid];\n    for (let row of newGrid) {\n      for (let node of row) {\n        node.isVisited = false;\n        node.isShortest = false;\n      }\n    }\n  };\n\n  const handleAlgoChange = (e) => {\n    let algo = null;\n    switch (e.target.value) {\n      case \"bfs\":\n        algo = ALGOS.bfs;\n        break;\n      case \"dfs\":\n        algo = ALGOS.dfs;\n        break;\n      case \"dijkstra\":\n        algo = ALGOS.dijkstra;\n        break;\n      case \"aStar\":\n        algo = ALGOS.aStar;\n        break;\n      default:\n        algo = ALGOS.bfs;\n    }\n    setAlgo(algo);\n    resetVisualization();\n  };\n\n  const handleAnimationType = (e) => {\n    let animationType = null;\n    switch (e.target.value) {\n      case \"swarm\":\n        animationType = ANIMATION_TYPE.swarm;\n        break;\n      case \"fade\":\n        animationType = ANIMATION_TYPE.fade;\n        break;\n      default:\n        animationType = ANIMATION_TYPE.swarm;\n    }\n    setAnimationType(animationType);\n    resetVisualization();\n  };\n\n  const changeAnimationTime = (e) => {\n    setAnimationTime(parseFloat(e.target.value));\n    document.documentElement.style.setProperty(\n      \"--animationTime\",\n      `${e.target.value / 1000}s`\n    );\n  };\n\n  const changeGridSize = (e) => {\n    setGridSize(parseInt(e.target.value));\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n  };\n\n  const changeWeightValue = (e) => {\n    setWeightValue(parseInt(e.target.value));\n  };\n\n  const randomizeGrid = () => {\n    setIsResetDisabled(false);\n    const newGrid = createEmptyGrid(gridSize);\n    const randomProbability = Math.random();\n    const maxWalls = Math.pow(gridSize, 2) * 0.2;\n\n    const startX = Math.round(Math.random() * (gridSize - 1));\n    const startY = Math.round(Math.random() * (gridSize - 1));\n    let endX = Math.round(Math.random() * (gridSize - 1));\n    let endY = Math.round(Math.random() * (gridSize - 1));\n\n    while (startX === endX && startY === endY) {\n      endX = Math.round(Math.random() * (gridSize - 1));\n      endY = Math.round(Math.random() * (gridSize - 1));\n    }\n\n    newGrid[startX][startY].isStart = true;\n    newGrid[endX][endY].isEnd = true;\n\n    const cellsToSetWall = [];\n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        if (!newGrid[row][col].isStart && !newGrid[row][col].isEnd) {\n          cellsToSetWall.push([row, col]);\n        }\n      }\n    }\n\n    for (let i = cellsToSetWall.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [cellsToSetWall[i], cellsToSetWall[j]] = [\n        cellsToSetWall[j],\n        cellsToSetWall[i],\n      ];\n    }\n\n    let numWalls = 0;\n    for (let i = 0; i < cellsToSetWall.length && numWalls < maxWalls; i++) {\n      const [row, col] = cellsToSetWall[i];\n      if (Math.random() <= randomProbability) {\n        newGrid[row][col].isWall = true;\n        numWalls++;\n      }\n    }\n    for (let i = 0; i < cellsToSetWall.length; i++) {\n      const [row, col] = cellsToSetWall[i];\n      if (\n        !newGrid[row][col].isStart &&\n        !newGrid[row][col].isEnd &&\n        !newGrid[row][col].isWall\n      )\n        newGrid[row][col].weight = Math.ceil(Math.random() * 10);\n    }\n\n    setStartNode([startX, startY]);\n    setEndNode([endX, endY]);\n    setGrid(newGrid);\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n  };\n\n  const scrollToGrid = () => {\n    gridRef.current.scrollIntoView({behaviour: \"smooth\", block: \"start\"});\n    execAlgo();\n  }\n\n  const execAlgo = async () => {\n    if (!visualizationRunning) {\n      if (startNode && endNode) {\n        if (\n          cachedVisited[algo].visited.length === 0 &&\n          !cachedVisited[algo].failedPrevious\n        ) {\n          setIsComputing(true);\n          let resultPromise = new Promise((resolve) => {\n            algoWorker.onmessage = (e) => {\n              resolve(e.data);\n            };\n          });\n\n          algoWorker.postMessage({\n            algo: algo,\n            grid: grid,\n            gridSize: gridSize,\n            startNode: startNode,\n            endNode: endNode,\n          });\n\n          let result = await resultPromise;\n          setIsComputing(false);\n          let newCachedVisited = [...cachedVisited];\n          if (result.success) {\n            if (algo === ALGOS.dfs) {\n              newCachedVisited[algo].visited = result.shortestPath;\n              await visualizeVisited(result.shortestPath);\n            } else {\n              newCachedVisited[algo].visited = result.visited;\n              newCachedVisited[algo].path = result.shortestPath;\n              await visualizeVisited(result.visited);\n            }\n            setCachedVisited(newCachedVisited);\n          } else {\n            newCachedVisited[algo].failedPrevious = true;\n            setCachedVisited(newCachedVisited);\n            alert(\"No path found.\");\n          }\n        } else if (cachedVisited[algo].failedPrevious) {\n          alert(\"No path found.\");\n        } else {\n          await visualizeVisited(cachedVisited[algo].visited);\n        }\n        if (algo === ALGOS.dfs) setVisualizationRunning(false);\n      } else {\n        alert(\"Please select a start and end node.\");\n      }\n    }\n  };\n  const visualizeVisited = (visited) => {\n    setVisualizationRunning(true);\n    return new Promise((resolve) => {\n      visited.forEach((node, index) => {\n        setTimeout(\n          () => {\n            setGrid((prevGrid) => {\n              const newGrid = [...prevGrid];\n              if (algo === ALGOS.dfs)\n                newGrid[node[0]][node[1]].isShortest = true;\n              else {\n                newGrid[node[0]][node[1]].isVisited = true;\n              }\n              return newGrid;\n            });\n            if (index === visited.length - 1) {\n              resolve();\n            }\n          },\n          algo === ALGOS.dfs\n            ? ((animationTime * 2) / visited.length) * index\n            : (animationTime / 2 / visited.length) * index\n        );\n      });\n    });\n  };\n\n  const visualizeShortestPath = (path) => {\n    return new Promise((resolve) => {\n      path.forEach((node, index) => {\n        setTimeout(() => {\n          setGrid((prevGrid) => {\n            const newGrid = [...prevGrid];\n            newGrid[node[0]][node[1]].isShortest = true;\n            return newGrid;\n          });\n          if (index === path.length - 1) {\n            resolve();\n          }\n        }, (animationTime / 2 / path.length) * index);\n      });\n    });\n  };\n\n  return (\n    <div className=\"parent-container\">\n      <div\n        className=\"grid-container\"\n        ref={gridRef}\n        onMouseDown={handleMouseDown}\n        onMouseUp={handleMouseUp}\n      >\n        <div className=\"grid-caption\">\n          <div className=\"caption-text\">\n            <p>\n              Click two cells to set a{\" \"}\n              <span style={{ color: \"#5ef19b\" }}>start</span> and{\" \"}\n              <span style={{ color: \"#fd686f\" }}>end</span> node, respectively.\n              <span className=\"info-icon\">\n                <FontAwesomeIcon icon={faInfoCircle}></FontAwesomeIcon>\n                <span className=\"tooltip tooltip-right\">\n                  Click on or drag your mouse over cells to <b>draw walls</b> (\n                  <span style={{ color: \"#5ef19b\", fontWeight: \"1000\" }}>\n                    start\n                  </span>{\" \"}\n                  and{\" \"}\n                  <span style={{ color: \"#fd686f\", fontWeight: \"1000\" }}>\n                    end\n                  </span>{\" \"}\n                  nodes must be set first).\n                </span>\n              </span>\n            </p>\n          </div>\n          <div className=\"grid-caption-buttons\">\n            <div>\n              <button\n                className=\"random-button\"\n                disabled={visualizationRunning || isComputing ? true : false}\n                onClick={randomizeGrid}\n                style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n              >\n                Random Grid\n              </button>\n            </div>\n            <div>\n              <button\n                className=\"reset-button\"\n                disabled={\n                  isResetDisabled || visualizationRunning || isComputing\n                    ? true\n                    : false\n                }\n                onClick={handleResetGrid}\n                style={{\n                  color:\n                    !visualizationRunning && !isResetDisabled\n                      ? \"white\"\n                      : \"grey\",\n                }}\n              >\n                Reset Grid\n              </button>\n            </div>\n          </div>\n        </div>\n        <div\n          className=\"grid\"\n          style={{\n            backgroundColor: `${isDarkMode ? \"#0D1117\" : \"white\"}`,\n            pointerEvents: `${!visualizationRunning ? \"auto\" : \"none\"}`,\n            overflow: \"hidden\",\n          }}\n        >\n          {isComputing ? (\n            <div className=\"loading-overlay\">\n              <img src={path + loadingGif} alt=\"Loading\" />\n            </div>\n          ) : null}\n          {grid.map((row, rowIndex) => (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, colIndex) => (\n                <Node\n                  key={rowIndex * gridSize + colIndex}\n                  start={node.isStart}\n                  end={node.isEnd}\n                  gridSize={gridSize}\n                  isWall={node.isWall}\n                  isVisited={node.isVisited}\n                  isShortest={node.isShortest}\n                  algo={algo}\n                  weight={node.weight}\n                  setAnimationCount={setAnimationCount}\n                  animationType={animationType}\n                  onClick={(e) => handleNodeClick(rowIndex, colIndex, e)}\n                  onMouseEnter={(e) => handleNodeDrag(rowIndex, colIndex, e)}\n                  isDarkMode={isDarkMode}\n                />\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n      <div className=\"menu\">\n        <h3>Customize</h3>\n        <div className=\"grid-size-menu\">\n          <label>Grid size</label>\n          <div className=\"size-slider\">\n            <input\n              disabled={visualizationRunning || isComputing ? true : false}\n              onChange={changeGridSize}\n              id=\"size_slider\"\n              type=\"range\"\n              min={DEFAULT_GRID_SIZE}\n              max={MAX_GRID_SIZE}\n              defaultValue={DEFAULT_GRID_SIZE}\n            />\n            <label>\n              {gridSize}x{gridSize}\n            </label>\n          </div>\n        </div>\n        <div className=\"algo-menu\">\n          <label>\n            Algorithm\n            <div className=\"info-icon\">\n              <FontAwesomeIcon icon={faInfoCircle}></FontAwesomeIcon>\n              <span className=\"tooltip tooltip-menu-down\">\n                <ol>\n                  <li>\n                    BFS, Dijkstra's and A* <b>guarantee</b> the shortest path\n                  </li>\n                  <li>\n                    DFS <b>does not guarantee</b> shortest path\n                  </li>\n                  <li>\n                    Dijkstra's and A* <b>require weights</b> (if no weights set,\n                    all weights cells default to weight of 1)\n                  </li>\n                  <li>\n                    Dijkstra's and A* regress to a BFS if uniform weights.\n                  </li>\n                </ol>\n              </span>\n            </div>\n          </label>\n          <select\n            disabled={visualizationRunning || isComputing ? true : false}\n            name=\"algo\"\n            id=\"algo\"\n            onChange={handleAlgoChange}\n            style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n          >\n            {Object.keys(ALGOS).map((key, idx) => {\n              return (\n                <option key={idx} value={key}>\n                  {algoToString(ALGOS[key])}\n                </option>\n              );\n            })}\n          </select>\n        </div>\n        <div className=\"animation-menu\">\n          <label>\n            Animation\n            <div className=\"info-icon\">\n              <FontAwesomeIcon icon={faInfoCircle}></FontAwesomeIcon>\n              <span className=\"tooltip tooltip-menu-right animation\">\n                Select an animation style for the pathfinding visualizer.\n              </span>\n            </div>\n          </label>\n          <select\n            disabled={\n              visualizationRunning || isComputing || algo === ALGOS.dfs\n                ? true\n                : false\n            }\n            name=\"animationType\"\n            id=\"animationType\"\n            onChange={handleAnimationType}\n            style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n          >\n            {Object.keys(ANIMATION_TYPE).map((key, idx) => {\n              return (\n                <option key={idx} value={key}>\n                  {animationTypeToString(ANIMATION_TYPE[key])}\n                </option>\n              );\n            })}\n          </select>\n        </div>\n        <div className=\"duration-menu\">\n          <label>Duration</label>\n          <div className=\"duration-slider\">\n            <input\n              disabled={visualizationRunning || isComputing ? true : false}\n              onChange={changeAnimationTime}\n              id=\"animation_time_slider\"\n              type=\"range\"\n              min={0.1}\n              max={10000}\n              defaultValue={animationTime}\n            />\n            <label>{Math.round((animationTime / 1000) * 2)} sec</label>\n          </div>\n        </div>\n        <div className=\"weight-menu\">\n          <label>\n            Weight value\n            <div className=\"info-icon\">\n              <FontAwesomeIcon icon={faInfoCircle}></FontAwesomeIcon>\n              <span className=\"tooltip tooltip-menu-right weight\">\n                Press and hold the CTRL key while clicking or dragging your\n                mouse over cells to set its weight to the configured weight\n                value.\n                <br />\n                <br />\n                <b>*NOTE:</b> Weights are only used for Dijkstra and A*.\n              </span>\n            </div>\n          </label>\n          <div className=\"weight-slider\">\n            <input\n              disabled={visualizationRunning || isComputing ? true : false}\n              onChange={changeWeightValue}\n              id=\"weight_slider\"\n              type=\"range\"\n              min={1}\n              max={10}\n              defaultValue={1}\n            />\n            <label>{weightValue}</label>\n          </div>\n        </div>\n        <div>\n          <button\n            className=\"visualize-button\"\n            disabled={\n              (visualizationRunning || isComputing) && startNode && endNode\n                ? true\n                : false\n            }\n            onClick={scrollToGrid}\n            style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n          >\n            {isComputing\n              ? \"Computing...\"\n              : !visualizationRunning\n              ? \"Start visualization\"\n              : \"Running...\"}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n});\n\nexport { ALGOS, ANIMATION_TYPE };\n","import { ALGOS } from \"../Grid\";\nimport { MinPriorityQueue } from \"@datastructures-js/priority-queue\";\n\nconst DIRECTIONS = [\n  [0, 1],\n  [-1, 0],\n  [1, 0],\n  [0, -1],\n];\n\nconst heuristic = (node, endNode) => {\n  // heuristic uses manhattan distance\n  let dx = Math.abs(node[0] - endNode[0]);\n  let dy = Math.abs(node[1] - endNode[1]);\n\n  return dx + dy;\n};\n\nconst isVisited = (visited, neighbour) => {\n  for (let i = 0; i < visited.length; i++) {\n    if (visited[i][0] === neighbour[0] && visited[i][1] === neighbour[1]) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst getNeighbours = (grid, node, gridSize, unvisited = []) => {\n  const [row, col] = node;\n  const neighbours = [];\n\n  for (const [dRow, dCol] of DIRECTIONS) {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n\n    if (\n      newRow >= 0 &&\n      newRow < gridSize &&\n      newCol >= 0 &&\n      newCol < gridSize &&\n      !isVisited(unvisited, [newRow, newCol]) &&\n      !grid[newRow][newCol].isWall\n    ) {\n      neighbours.push([newRow, newCol]);\n    }\n  }\n\n  return neighbours;\n};\n\nexport const runAlgo = (algo, grid, gridSize, startNode, endNode) => {\n  let result = {};\n\n  switch (algo) {\n    case ALGOS.bfs:\n      result = execBFS(grid, gridSize, startNode, endNode);\n      break;\n    case ALGOS.dfs:\n      let path = [];\n      result = execDFS(grid, gridSize, startNode, endNode, path);\n      result.shortestPath = path;\n      break;\n    case ALGOS.dijkstra:\n      result = execDijkstras(grid, gridSize, startNode, endNode);\n      break;\n    case ALGOS.aStar:\n      result = execAStar(grid, gridSize, startNode, endNode);\n      break;\n    default:\n      result.success = false;\n  }\n  return result;\n};\n\nconst execBFS = (grid, gridLength, startNode, endNode) => {\n  let queue = [];\n  let visited = [];\n\n  visited.push(startNode);\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    let currNode = queue.shift();\n    // extract the shortest path\n    if (currNode[0] === endNode[0] && currNode[1] === endNode[1]) {\n      let path = [];\n      let currentNode = endNode;\n      while (\n        currentNode[0] !== startNode[0] ||\n        currentNode[1] !== startNode[1]\n      ) {\n        path.unshift(currentNode);\n        currentNode = grid[currentNode[0]][currentNode[1]].parent;\n        if (!currentNode) break;\n      }\n      return { success: true, visited: visited, shortestPath: path };\n    }\n\n    let neighbours = getNeighbours(grid, currNode, gridLength);\n\n    neighbours.forEach((neighbour) => {\n      if (!isVisited(visited, neighbour)) {\n        queue.push(neighbour);\n        visited.push(neighbour);\n        grid[neighbour[0]][neighbour[1]].parent = currNode;\n      }\n    });\n  }\n  return { success: false };\n};\n\nconst execDFS = (grid, gridLength, startNode, endNode, visited) => {\n  let stack = [];\n\n  stack.push(startNode);\n\n  while (stack.length > 0) {\n    let currentNode = stack.pop();\n\n    if (currentNode[0] === endNode[0] && currentNode[1] === endNode[1]) {\n      return { success: true };\n    }\n\n    if (!isVisited(visited, currentNode)) {\n      visited.push(currentNode);\n      let neighbours = getNeighbours(grid, currentNode, gridLength);\n      stack.push(...neighbours);\n    }\n  }\n\n  return { success: false };\n};\n\nconst execDijkstras = (grid, gridLength, startNode, endNode) => {\n  let nodeMap = {};\n  let visited = [];\n  let gScore = {};\n  let unvisited = new MinPriorityQueue((node) => gScore[node] || Infinity);\n  unvisited.push(startNode);\n  gScore[startNode] = 0;\n\n  while (!unvisited.isEmpty()) {\n    let currNode = unvisited.pop();\n    if (!isVisited(visited, currNode)) visited.push(currNode);\n    if (currNode[0] === endNode[0] && currNode[1] === endNode[1]) {\n      let path = [];\n      let nodeInPath = endNode;\n\n      while (nodeInPath[0] !== startNode[0] || nodeInPath[1] !== startNode[1]) {\n        path.push(nodeInPath);\n        nodeInPath = nodeMap[nodeInPath];\n      }\n      return { success: true, visited: visited, shortestPath: path.reverse() };\n    }\n    let neighbours = getNeighbours(grid, currNode, gridLength, visited);\n    for (const neighbour of neighbours) {\n      let newGScore = gScore[currNode] + grid[neighbour[0]][neighbour[1]].weight;\n      if (!gScore.hasOwnProperty(neighbour) || newGScore < gScore[neighbour]) {\n        nodeMap[neighbour] = currNode;\n        gScore[neighbour] = newGScore;\n        unvisited.push(neighbour);\n      }\n    }\n  }\n\n  return { success: false };\n};\n\n\nconst execAStar = (grid, gridLength, startNode, endNode) => {\n  let unvisitedQueue = new MinPriorityQueue(\n    (node) => fScore[node]\n  );\n  unvisitedQueue.push(startNode);\n  let visited = [];\n  let nodeMap = {};\n  let gScore = {};\n  let fScore = {};\n\n  gScore[startNode] = 0;\n  fScore[startNode] = heuristic(startNode, endNode);\n\n  while (!unvisitedQueue.isEmpty()) {\n    let currNode = unvisitedQueue.pop();\n    if (!isVisited(visited, currNode)) visited.push(currNode);\n    if (currNode[0] === endNode[0] && currNode[1] === endNode[1]) {\n      let path = [];\n      let nodeInPath = endNode;\n\n      while (nodeInPath[0] !== startNode[0] || nodeInPath[1] !== startNode[1]) {\n        path.push(nodeInPath);\n        nodeInPath = nodeMap[nodeInPath];\n      }\n      return { success: true, visited: visited, shortestPath: path.reverse() };\n    }\n    let neighbours = getNeighbours(grid, currNode, gridLength);\n    for (const neighbour of neighbours) {\n      let tentativeGScore =\n        gScore[currNode] + grid[neighbour[0]][neighbour[1]].weight;\n      if (!gScore.hasOwnProperty(neighbour)) gScore[neighbour] = Infinity;\n      if (tentativeGScore < gScore[neighbour]) {\n        nodeMap[neighbour] = currNode;\n        gScore[neighbour] = tentativeGScore;\n        fScore[neighbour] = tentativeGScore + heuristic(neighbour, endNode);\n\n        let found = unvisitedQueue\n          .toArray()\n          .some((node) => node[0] === neighbour[0] && node[1] === neighbour[1]);\n\n        if (!found) {\n          unvisitedQueue.push(neighbour);\n        }\n      }\n    }\n  }\n  return { success: false };\n};\n","import { runAlgo } from \"./algorithms\";\n\nonmessage = (e) => {\n  const { algo, grid, gridSize, startNode, endNode } = e.data;\n\n  const result = runAlgo(algo, grid, gridSize, startNode, endNode);\n\n  postMessage(result);\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [300], function() { return __webpack_require__(565); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"300\":\"92670499\",\"565\":\"08279896\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/css/\" + chunkId + \".\" + \"066ef5bd\" + \".chunk.css\";\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/Pathfinding-Visualizer/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t565: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkpathfinding_app\"] = self[\"webpackChunkpathfinding_app\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(300).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["ALGOS","bfs","dfs","dijkstra","aStar","DIRECTIONS","heuristic","node","endNode","Math","abs","isVisited","visited","neighbour","i","length","getNeighbours","grid","gridSize","unvisited","arguments","undefined","_node","_slicedToArray","row","col","neighbours","_i","_DIRECTIONS","_DIRECTIONS$_i","newRow","newCol","isWall","push","execBFS","gridLength","startNode","queue","_loop","currNode","shift","path","currentNode","unshift","parent","v","success","shortestPath","forEach","_ret","execDFS","stack","pop","apply","_toConsumableArray","execDijkstras","nodeMap","gScore","MinPriorityQueue","Infinity","isEmpty","nodeInPath","reverse","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","newGScore","weight","hasOwnProperty","err","e","f","execAStar","unvisitedQueue","fScore","_step2","_iterator2","_loop2","tentativeGScore","toArray","some","onmessage","_e$data","data","result","algo","runAlgo","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","j","Object","keys","every","key","splice","r","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","reduce","promises","u","miniCssF","obj","prop","prototype","call","p","b","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","next","then"],"sourceRoot":""}