{"version":3,"file":"static/js/565.b3182101.chunk.js","mappings":"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","sources":["Grid.js","utils/algorithms.js","utils/webworker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import React, { useEffect, useState, useMemo } from \"react\";\nimport Node from \"./Node\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faInfoCircle } from \"@fortawesome/free-solid-svg-icons\";\nimport \"./Grid.css\";\n\nconst path = process.env.PUBLIC_URL;\nconst loadingGif = \"/images/loading.gif\";\n\nconst DEFAULT_GRID_SIZE = 10; // square root of total grid size;\nconst MAX_GRID_SIZE = 50;\nconst ALGOS = { bfs: 0, dfs: 1, dijkstra: 2, aStar: 3 };\nconst ANIMATION_TYPE = { fade: 0, swarm: 1 };\n\nconst algoToString = (algo) => {\n  let algoString = \"\";\n  if (algo === ALGOS.bfs) algoString = \"Breadth-First Search\";\n  else if (algo === ALGOS.dfs) algoString = \"Depth-First Search\";\n  else if (algo === ALGOS.dijkstra) algoString = \"Dijkstra Shortest Path\";\n  else if (algo === ALGOS.aStar) algoString = \"A* Shortest Path\";\n  return algoString;\n};\n\nconst animationTypeToString = (animationType) => {\n  let animationTypeString = \"\";\n  if (animationType === ANIMATION_TYPE.swarm) animationTypeString = \"Swarm\";\n  else if (animationType === ANIMATION_TYPE.fade) animationTypeString = \"Fade\";\n  return animationTypeString;\n};\n\nconst createEmptyGrid = (gridSize) => {\n  const grid = [];\n  for (let row = 0; row < gridSize; row++) {\n    grid.push(\n      Array.from({ length: gridSize }, () => ({\n        isWall: false,\n        isVisited: false,\n        isStart: false,\n        isEnd: false,\n        isShortest: false,\n        weight: 1,\n      }))\n    );\n  }\n  return grid;\n};\n\nconst resizeGrid = (grid, newGridSize) => {\n  const oldGridSize = grid.length;\n  const size = newGridSize > oldGridSize ? oldGridSize : newGridSize;\n  let isStart = false;\n  let isEnd = false;\n\n  let newGrid = createEmptyGrid(newGridSize);\n\n  for (let row = 0; row < size; row++) {\n    for (let col = 0; col < size; col++) {\n      if (grid[row][col].isStart) {\n        newGrid[row][col].isStart = true;\n        isStart = true;\n      } else if (grid[row][col].isEnd) {\n        newGrid[row][col].isEnd = true;\n        isEnd = true;\n      } else if (grid[row][col].isWall) newGrid[row][col].isWall = true;\n      else if (grid[row][col].weight > 0)\n        newGrid[row][col].weight = grid[row][col].weight;\n    }\n  }\n  return [newGrid, isStart, isEnd];\n};\n\nexport const Grid = React.memo(({ isDarkMode }) => {\n  const [grid, setGrid] = useState(createEmptyGrid(DEFAULT_GRID_SIZE));\n  const [gridSize, setGridSize] = useState(DEFAULT_GRID_SIZE);\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [startNode, setStartNode] = useState(null);\n  const [endNode, setEndNode] = useState(null);\n  const [visualizationRunning, setVisualizationRunning] = useState(false);\n  const [isComputing, setIsComputing] = useState(false);\n  const [algo, setAlgo] = useState(ALGOS.bfs);\n  const [animationTime, setAnimationTime] = useState(2000);\n  const [animationCount, setAnimationCount] = useState(0);\n  const [animationType, setAnimationType] = useState(ANIMATION_TYPE.fade);\n  const [cachedVisited, setCachedVisited] = useState(\n    Array.from({ length: Object.keys(ALGOS).length }, () => ({\n      visited: [],\n      path: [],\n      failedPrevious: false,\n    }))\n  );\n  const [algoWorker, setAlgoWorker] = useState(\n    null\n  );\n\n  useEffect(() => {\n    document.documentElement.style.setProperty(\n      \"--animationTime\",\n      `${animationTime / 2000}s`\n    );\n\n    const gridContainer = document.querySelector(\".grid-container\");\n    gridContainer.addEventListener(\"animationend\", handleAnimationEnd);\n\n    setAlgoWorker(new Worker(new URL(\"./utils/webworker.js\", import.meta.url)))\n\n  }, []);\n\n  useEffect(() => {\n    const execShortestPath = async () => {\n      if (algo !== ALGOS.dfs) {\n        if (animationCount === cachedVisited[algo].visited.length - 2) {\n          await visualizeShortestPath(cachedVisited[algo].path);\n          setAnimationCount(0);\n          setVisualizationRunning(false);\n        }\n      }\n    };\n    execShortestPath();\n  }, [animationCount]);\n\n  useEffect(() => {\n    let newGridProps = resizeGrid(grid, gridSize);\n    setGrid(newGridProps[0]);\n    if (!newGridProps[1]) setStartNode(null);\n    if (!newGridProps[2]) setEndNode(null);\n  }, [gridSize]);\n\n  useEffect(() => {\n    if (!visualizationRunning) resetVisualization();\n  }, [visualizationRunning]);\n\n  const handleAnimationEnd = (e) => {\n    if (\n      e.target.classList.contains(\"visited-swarm\") ||\n      e.target.classList.contains(\"visited-fade\")\n    ) {\n      setAnimationCount((prev) => prev + 1);\n    }\n  };\n\n  const handleNodeClick = (row, col) => {\n    const newGrid = [...grid];\n    if (startNode && endNode) {\n      if (newGrid[row][col].isStart) {\n        newGrid[row][col].isStart = false;\n        setStartNode(null);\n      } else if (newGrid[row][col].isEnd) {\n        newGrid[row][col].isEnd = false;\n        setEndNode(null);\n      } else {\n        newGrid[row][col].isWall = !newGrid[row][col].isWall;\n        newGrid[row][col].weight = 0;\n      }\n    } else if (!startNode) {\n      if (newGrid[row][col].isEnd) {\n        newGrid[row][col].isEnd = false;\n        setEndNode(null);\n      } else {\n        newGrid[row][col].isStart = true;\n        newGrid[row][col].isWall = false;\n        newGrid[row][col].weight = 0;\n        setStartNode([row, col]);\n      }\n    } else if (!endNode) {\n      if (newGrid[row][col].isStart) {\n        newGrid[row][col].isStart = false;\n        setStartNode(null);\n      } else {\n        newGrid[row][col].isEnd = true;\n        newGrid[row][col].isWall = false;\n        newGrid[row][col].weight = 0;\n        setEndNode([row, col]);\n      }\n    }\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n    setGrid(newGrid);\n  };\n\n  const handleNodeDrag = (row, col) => {\n    if (isMouseDown && startNode && endNode) {\n      const newGrid = [...grid];\n      if (!newGrid[row][col].isStart && !newGrid[row][col].isEnd) {\n        newGrid[row][col].isWall = !newGrid[row][col].isWall;\n        newGrid[row][col].weight = 0;\n      }\n      setCachedVisited(\n        Array.from({ length: Object.keys(ALGOS).length }, () => ({\n          visited: [],\n          path: [],\n          failedPrevious: false,\n        }))\n      );\n      setGrid(newGrid);\n    }\n  };\n\n  const handleMouseDown = () => {\n    setIsMouseDown(true);\n  };\n\n  const handleMouseUp = () => {\n    setIsMouseDown(false);\n  };\n\n  const handleResetGrid = () => {\n    setGrid(createEmptyGrid(gridSize));\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n    setStartNode(null);\n    setEndNode(null);\n  };\n\n  const resetVisualization = () => {\n    const newGrid = [...grid];\n    for (let row of newGrid) {\n      for (let node of row) {\n        node.isVisited = false;\n        node.isShortest = false;\n      }\n    }\n  };\n\n  const handleAlgoChange = (e) => {\n    let algo = null;\n    switch (e.target.value) {\n      case \"bfs\":\n        algo = ALGOS.bfs;\n        break;\n      case \"dfs\":\n        algo = ALGOS.dfs;\n        break;\n      case \"dijkstra\":\n        algo = ALGOS.dijkstra;\n        break;\n      case \"aStar\":\n        algo = ALGOS.aStar;\n        break;\n      default:\n        algo = ALGOS.bfs;\n    }\n    setAlgo(algo);\n    resetVisualization();\n  };\n\n  const handleAnimationType = (e) => {\n    let animationType = null;\n    switch (e.target.value) {\n      case \"swarm\":\n        animationType = ANIMATION_TYPE.swarm;\n        break;\n      case \"fade\":\n        animationType = ANIMATION_TYPE.fade;\n        break;\n      default:\n        animationType = ANIMATION_TYPE.swarm;\n    }\n    setAnimationType(animationType);\n    resetVisualization();\n  };\n\n  const changeAnimationTime = (e) => {\n    setAnimationTime(parseFloat(e.target.value));\n    document.documentElement.style.setProperty(\n      \"--animationTime\",\n      `${e.target.value / 1000}s`\n    );\n  };\n\n  const changeGridSize = (e) => {\n    setGridSize(parseInt(e.target.value));\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n  };\n\n  const randomizeGrid = () => {\n    const newGrid = createEmptyGrid(gridSize);\n    const randomProbability = Math.random();\n    const maxWalls = Math.pow(gridSize, 2) * 0.2;\n\n    const startX = Math.round(Math.random() * (gridSize - 1));\n    const startY = Math.round(Math.random() * (gridSize - 1));\n    let endX = Math.round(Math.random() * (gridSize - 1));\n    let endY = Math.round(Math.random() * (gridSize - 1));\n\n    while (startX === endX && startY === endY) {\n      endX = Math.round(Math.random() * (gridSize - 1));\n      endY = Math.round(Math.random() * (gridSize - 1));\n    }\n\n    newGrid[startX][startY].isStart = true;\n    newGrid[endX][endY].isEnd = true;\n\n    const cellsToSetWall = [];\n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        if (!newGrid[row][col].isStart && !newGrid[row][col].isEnd) {\n          cellsToSetWall.push([row, col]);\n        }\n      }\n    }\n\n    for (let i = cellsToSetWall.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [cellsToSetWall[i], cellsToSetWall[j]] = [\n        cellsToSetWall[j],\n        cellsToSetWall[i],\n      ];\n    }\n\n    let numWalls = 0;\n    for (let i = 0; i < cellsToSetWall.length && numWalls < maxWalls; i++) {\n      const [row, col] = cellsToSetWall[i];\n      if (Math.random() <= randomProbability) {\n        newGrid[row][col].isWall = true;\n        numWalls++;\n      }\n    }\n    for (let i = 0; i < cellsToSetWall.length; i++) {\n      const [row, col] = cellsToSetWall[i];\n      if (\n        !newGrid[row][col].isStart &&\n        !newGrid[row][col].isEnd &&\n        !newGrid[row][col].isWall\n      )\n        newGrid[row][col].weight = Math.ceil(Math.random() * 10);\n    }\n\n    setStartNode([startX, startY]);\n    setEndNode([endX, endY]);\n    setGrid(newGrid);\n    setCachedVisited(\n      Array.from({ length: Object.keys(ALGOS).length }, () => ({\n        visited: [],\n        path: [],\n        failedPrevious: false,\n      }))\n    );\n  };\n\n  const execAlgo = async () => {\n    if (!visualizationRunning) {\n      if (startNode && endNode) {\n        if (\n          cachedVisited[algo].visited.length === 0 &&\n          !cachedVisited[algo].failedPrevious\n        ) {\n          setIsComputing(true);\n          let resultPromise = new Promise((resolve) => {\n            algoWorker.onmessage = (e) => {\n              resolve(e.data);\n            };\n          });\n\n          algoWorker.postMessage({\n            algo: algo,\n            grid: grid,\n            gridSize: gridSize,\n            startNode: startNode,\n            endNode: endNode,\n          });\n\n          let result = await resultPromise;\n          setIsComputing(false);\n          let newCachedVisited = [...cachedVisited];\n          if (result.success) {\n            if (algo === ALGOS.dfs) {\n              newCachedVisited[algo].visited = result.shortestPath;\n              await visualizeVisited(result.shortestPath);\n            } else {\n              newCachedVisited[algo].visited = result.visited;\n              newCachedVisited[algo].path = result.shortestPath;\n              await visualizeVisited(result.visited);\n            }\n            setCachedVisited(newCachedVisited);\n          } else {\n            newCachedVisited[algo].failedPrevious = true;\n            setCachedVisited(newCachedVisited);\n            alert(\"No path found.\");\n          }\n        } else if (cachedVisited[algo].failedPrevious) {\n          alert(\"No path found.\");\n        } else {\n          await visualizeVisited(cachedVisited[algo].visited);\n        }\n        if (algo === ALGOS.dfs) setVisualizationRunning(false);\n      } else {\n        alert(\"Please select a start and end node.\");\n      }\n    }\n  };\n  const visualizeVisited = (visited) => {\n    setVisualizationRunning(true);\n    return new Promise((resolve) => {\n      visited.forEach((node, index) => {\n        setTimeout(\n          () => {\n            setGrid((prevGrid) => {\n              const newGrid = [...prevGrid];\n              if (algo === ALGOS.dfs)\n                newGrid[node[0]][node[1]].isShortest = true;\n              else {\n                newGrid[node[0]][node[1]].isVisited = true;\n              }\n              return newGrid;\n            });\n            if (index === visited.length - 1) {\n              resolve();\n            }\n          },\n          algo === ALGOS.dfs\n            ? ((animationTime * 2) / visited.length) * index\n            : (animationTime / 2 / visited.length) * index\n        );\n      });\n    });\n  };\n\n  const visualizeShortestPath = (path) => {\n    return new Promise((resolve) => {\n      path.forEach((node, index) => {\n        setTimeout(() => {\n          setGrid((prevGrid) => {\n            const newGrid = [...prevGrid];\n            newGrid[node[0]][node[1]].isShortest = true;\n            return newGrid;\n          });\n          if (index === path.length - 1) {\n            resolve();\n          }\n        }, (animationTime / 2 / path.length) * index);\n      });\n    });\n  };\n\n  return (\n    <div className=\"parent-container\">\n      <div\n        className=\"grid-container\"\n        onMouseDown={handleMouseDown}\n        onMouseUp={handleMouseUp}\n      >\n        <div className=\"grid-caption\">\n          <div className=\"caption-text\">\n            <p>\n              Click two cells to set a{\" \"}\n              <span style={{ color: \"#5ef19b\" }}>start</span> and{\" \"}\n              <span style={{ color: \"#fd686f\" }}>end</span> node, respectively.\n              <span className=\"info-icon\">\n                <FontAwesomeIcon icon={faInfoCircle}></FontAwesomeIcon>\n                <span className=\"tooltip-text-right\">\n                  Click on or drag your mouse over cells to <b>draw walls</b> (\n                  <span style={{ color: \"#5ef19b\", fontWeight: \"1000\" }}>\n                    start\n                  </span>{\" \"}\n                  and{\" \"}\n                  <span style={{ color: \"#fd686f\", fontWeight: \"1000\" }}>\n                    end\n                  </span>{\" \"}\n                  nodes must be set first).\n                </span>\n              </span>\n            </p>\n          </div>\n          <div className=\"grid-caption-buttons\">\n            <div>\n              <button\n                className=\"random-button\"\n                disabled={visualizationRunning || isComputing ? true : false}\n                onClick={randomizeGrid}\n                style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n              >\n                Random Grid\n              </button>\n            </div>\n            <div>\n              <button\n                className=\"reset-button\"\n                disabled={visualizationRunning || isComputing ? true : false}\n                onClick={handleResetGrid}\n                style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n              >\n                Reset Grid\n              </button>\n            </div>\n          </div>\n        </div>\n        <div\n          className=\"grid\"\n          style={{\n            backgroundColor: `${isDarkMode ? \"#0D1117\" : \"white\"}`,\n            pointerEvents: `${!visualizationRunning ? \"auto\" : \"none\"}`,\n          }}\n        >\n          {isComputing ? (\n            <div className=\"loading-overlay\">\n              <img src={path + loadingGif} alt=\"Loading\" />\n            </div>\n          ) : null}\n          {grid.map((row, rowIndex) => (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, colIndex) => (\n                <Node\n                  key={rowIndex * gridSize + colIndex}\n                  start={node.isStart}\n                  end={node.isEnd}\n                  gridSize={gridSize}\n                  isWall={node.isWall}\n                  isVisited={node.isVisited}\n                  isShortest={node.isShortest}\n                  algo={algo}\n                  weight={node.weight}\n                  setAnimationCount={setAnimationCount}\n                  animationType={animationType}\n                  onClick={() => handleNodeClick(rowIndex, colIndex)}\n                  onMouseEnter={() => handleNodeDrag(rowIndex, colIndex)}\n                  isDarkMode={isDarkMode}\n                />\n              ))}\n            </div>\n          ))}\n        </div>\n        <div className=\"legend\">\n          <div className=\"legend-item\">\n            <span className=\"legend-node green\"></span>\n            <label className=\"legend-label\">Start node</label>\n          </div>\n          <div className=\"legend-item\">\n            <span className=\"legend-node red\"></span>\n            <label className=\"legend-label\">End node</label>\n          </div>\n          <div className=\"legend-item\">\n            <span className=\"legend-node blue\"></span>\n            <label className=\"legend-label\">Wall</label>\n          </div>\n          <div className=\"legend-item\">\n            <span className=\"legend-node grey\"></span>\n            <label className=\"legend-label\">Weight</label>\n          </div>\n        </div>\n      </div>\n      <div className=\"menu\">\n        <h3>Customize</h3>\n        <div className=\"grid-size-menu\">\n          <label>Grid size</label>\n          <div className=\"size-slider\">\n            <input\n              disabled={visualizationRunning || isComputing ? true : false}\n              onChange={changeGridSize}\n              id=\"size_slider\"\n              type=\"range\"\n              min={DEFAULT_GRID_SIZE}\n              max={MAX_GRID_SIZE}\n              defaultValue={DEFAULT_GRID_SIZE}\n            />\n            <label>\n              {gridSize}x{gridSize}\n            </label>\n          </div>\n        </div>\n        <div className=\"algo-menu\">\n          <label>\n            Algorithm\n            <div className=\"info-icon\">\n              <FontAwesomeIcon icon={faInfoCircle}></FontAwesomeIcon>\n              <span className=\"tooltip-text-down\">\n                <ol>\n                  <li>\n                    BFS, Dijkstra's and A* <b>guarantee</b> the shortest path\n                  </li>\n                  <li>\n                    DFS <b>does not guarantee</b> shortest path\n                  </li>\n                  <li>\n                    Dijkstra's and A* <b>require weights</b> (if no weights set,\n                    all weights cells default to weight of 1)\n                  </li>\n                  <li>\n                    Dijkstra's and A* regress to a BFS if uniform weights.\n                  </li>\n                </ol>\n              </span>\n            </div>\n          </label>\n          <select\n            disabled={visualizationRunning || isComputing ? true : false}\n            name=\"algo\"\n            id=\"algo\"\n            onChange={handleAlgoChange}\n            style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n          >\n            {Object.keys(ALGOS).map((key, idx) => {\n              return (\n                <option key={idx} value={key}>\n                  {algoToString(ALGOS[key])}\n                </option>\n              );\n            })}\n          </select>\n        </div>\n        <div className=\"animation-menu\">\n          <label>\n            Animation\n            <div className=\"info-icon\">\n              <FontAwesomeIcon icon={faInfoCircle}></FontAwesomeIcon>\n              <span className=\"tooltip-text-right-animation\">\n                Select an animation style for the pathfinding visualizer.\n              </span>\n            </div>\n          </label>\n          <select\n            disabled={\n              (visualizationRunning || isComputing) || algo === ALGOS.dfs\n                ? true\n                : false\n            }\n            name=\"animationType\"\n            id=\"animationType\"\n            onChange={handleAnimationType}\n            style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n          >\n            {Object.keys(ANIMATION_TYPE).map((key, idx) => {\n              return (\n                <option key={idx} value={key}>\n                  {animationTypeToString(ANIMATION_TYPE[key])}\n                </option>\n              );\n            })}\n          </select>\n        </div>\n        <div className=\"duration-menu\">\n          <label>Duration</label>\n          <div className=\"duration-slider\">\n            <input\n              disabled={visualizationRunning || isComputing ? true : false}\n              onChange={changeAnimationTime}\n              id=\"animation_time_slider\"\n              type=\"range\"\n              min={0.1}\n              max={10000}\n              defaultValue={animationTime}\n            />\n            <label>{Math.round((animationTime / 1000) * 2)} sec</label>\n          </div>\n        </div>\n\n        <div>\n          <button\n            className=\"visualize-button\"\n            disabled={\n              (visualizationRunning || isComputing) && startNode && endNode\n                ? true\n                : false\n            }\n            onClick={execAlgo}\n            style={{ color: !visualizationRunning ? \"white\" : \"grey\" }}\n          >\n            {isComputing\n              ? \"Computing...\"\n              : !visualizationRunning\n              ? \"Start visualization\"\n              : \"Running...\"}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n});\n\nexport { ALGOS, ANIMATION_TYPE };\n","import { ALGOS } from \"../Grid\";\n\nconst DIRECTIONS = [\n  [0, 1],\n  [-1, 0],\n  [1, 0],\n  [0, -1],\n];\n\nconst isVisited = (visited, neighbour) => {\n  for (let i = 0; i < visited.length; i++) {\n    if (visited[i][0] === neighbour[0] && visited[i][1] === neighbour[1]) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst getNeighbours = (grid, node, gridSize, unvisited = []) => {\n  const [row, col] = node;\n  const neighbours = [];\n\n  for (const [dRow, dCol] of DIRECTIONS) {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n\n    if (\n      newRow >= 0 &&\n      newRow < gridSize &&\n      newCol >= 0 &&\n      newCol < gridSize &&\n      !isVisited(unvisited, [newRow, newCol]) &&\n      !grid[newRow][newCol].isWall\n    ) {\n      neighbours.push([newRow, newCol]);\n    }\n  }\n\n  return neighbours;\n};\n\nconst findNodeWithSmallestDistance = (nodeMap, visited) => {\n  let smallestDistance = Infinity;\n  let smallestNode = null;\n\n  for (const [key, value] of nodeMap) {\n    if (\n      value.distance < smallestDistance &&\n      !isVisited(visited, JSON.parse(key))\n    ) {\n      smallestDistance = value.distance;\n      smallestNode = key;\n    }\n  }\n\n  return smallestNode;\n};\n\nconst getNeighbourDistances = (grid, neighbours) => {\n  let neighbourDistances = new Map();\n  neighbours.forEach((neighbour) => {\n    neighbourDistances.set(\n      JSON.stringify(neighbour),\n      grid[neighbour[0]][neighbour[1]].weight\n    );\n  });\n  return neighbourDistances;\n};\n\nexport const runAlgo = (algo, grid, gridSize, startNode, endNode) => {\n  let result = {};\n\n  switch (algo) {\n    case ALGOS.bfs:\n      result = execBFS(grid, gridSize, startNode, endNode);\n      break;\n    case ALGOS.dfs:\n      let path = [];\n      result = execDFS(grid, gridSize, startNode, endNode, path);\n      result.shortestPath = path;\n      break;\n    case ALGOS.dijkstra:\n      result = execDijkstras(grid, gridSize, startNode, endNode);\n      break;\n    default:\n      result.success = false;\n  }\n  return result;\n};\n\nconst execBFS = (grid, gridLength, startNode, endNode) => {\n  let queue = [];\n  let visited = [];\n\n  visited.push(startNode);\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    let currNode = queue.shift();\n    // extract the shortest path\n    if (currNode[0] === endNode[0] && currNode[1] === endNode[1]) {\n      let path = [];\n      let currentNode = endNode;\n      while (\n        currentNode[0] !== startNode[0] ||\n        currentNode[1] !== startNode[1]\n      ) {\n        path.unshift(currentNode);\n        currentNode = grid[currentNode[0]][currentNode[1]].parent;\n        if (!currentNode) break;\n      }\n      return { success: true, visited: visited, shortestPath: path };\n    }\n\n    let neighbours = getNeighbours(grid, currNode, gridLength);\n\n    neighbours.forEach((neighbour) => {\n      if (!isVisited(visited, neighbour)) {\n        queue.push(neighbour);\n        visited.push(neighbour);\n        grid[neighbour[0]][neighbour[1]].parent = currNode;\n      }\n    });\n  }\n  return { success: false };\n};\n\nconst execDFS = (grid, gridLength, startNode, endNode, visited) => {\n  let stack = [];\n\n  stack.push(startNode);\n\n  while (stack.length > 0) {\n    let currentNode = stack.pop();\n\n    if (currentNode[0] === endNode[0] && currentNode[1] === endNode[1]) {\n      return { success: true };\n    }\n\n    if (!isVisited(visited, currentNode)) {\n      visited.push(currentNode);\n      let neighbours = getNeighbours(grid, currentNode, gridLength);\n      stack.push(...neighbours);\n    }\n  }\n\n  return { success: false };\n};\n\nconst execDijkstras = (grid, gridLength, startNode, endNode) => {\n  let nodeMap = new Map();\n  let visited = [];\n  let unvisited = [];\n\n  for (let row = 0; row < gridLength; row++) {\n    for (let col = 0; col < gridLength; col++) {\n      if (!grid[row][col].isWall) {\n        unvisited.push([row, col]);\n        nodeMap.set(JSON.stringify([row, col]), {\n          distance: Infinity,\n          prev: null,\n        });\n      }\n    }\n  }\n\n  let currNode = startNode;\n  nodeMap.set(JSON.stringify(currNode), { distance: 0, prev: null });\n\n  while (unvisited.length !== 0) {\n    let neighbourDistances = getNeighbourDistances(\n      grid,\n      getNeighbours(grid, currNode, gridLength, visited)\n    );\n    // update neighbour's shortest distance in nodeMap\n    for (const [key, val] of neighbourDistances) {\n      let oldNodeDistance = nodeMap.get(key).distance;\n      let newNodeDistance =\n        val + nodeMap.get(JSON.stringify(currNode)).distance;\n      if (newNodeDistance <= oldNodeDistance) {\n        nodeMap.set(key, {\n          distance: newNodeDistance,\n          prev: currNode,\n        });\n      }\n    }\n\n    visited.push(currNode);\n    if (currNode[0] === endNode[0] && currNode[1] === endNode[1]) {\n      let path = [];\n      let nodeInPath = endNode;\n      while (nodeInPath[0] !== startNode[0] || nodeInPath[1] !== startNode[1]) {\n        path.push(nodeInPath);\n        nodeInPath = nodeMap.get(JSON.stringify(nodeInPath)).prev;\n      }\n      return { success: true, visited: visited, shortestPath: path.reverse() };\n    }\n    unvisited.splice(\n      unvisited.findIndex(\n        (node) => node[0] === currNode[0] && node[1] === currNode[1]\n      ),\n      1\n    );\n    currNode = JSON.parse(findNodeWithSmallestDistance(nodeMap, visited));\n  }\n\n  return { success: false };\n};\n","import { runAlgo } from \"./algorithms\";\n\nonmessage = (e) => {\n  const { algo, grid, gridSize, startNode, endNode } = e.data;\n\n  const result = runAlgo(algo, grid, gridSize, startNode, endNode);\n\n  postMessage(result);\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [669], function() { return __webpack_require__(565); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"565\":\"b3182101\",\"669\":\"6be0c80b\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/css/\" + chunkId + \".\" + \"6b3c068c\" + \".chunk.css\";\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/Pathfinding-Visualizer/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t565: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkpathfinding_app\"] = self[\"webpackChunkpathfinding_app\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(669).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["ALGOS","bfs","dfs","dijkstra","aStar","DIRECTIONS","isVisited","visited","neighbour","i","length","getNeighbours","grid","node","gridSize","unvisited","arguments","undefined","_node","_slicedToArray","row","col","neighbours","_i","_DIRECTIONS","_DIRECTIONS$_i","newRow","newCol","isWall","push","findNodeWithSmallestDistance","nodeMap","_step","smallestDistance","Infinity","smallestNode","_iterator","_createForOfIteratorHelper","s","n","done","_step$value","value","key","distance","JSON","parse","err","e","f","getNeighbourDistances","neighbourDistances","Map","forEach","set","stringify","weight","execBFS","gridLength","startNode","endNode","queue","_loop","currNode","shift","path","currentNode","unshift","parent","v","success","shortestPath","_ret","execDFS","stack","pop","apply","_toConsumableArray","execDijkstras","prev","_step2","_iterator2","_step2$value","val","oldNodeDistance","get","newNodeDistance","nodeInPath","reverse","splice","findIndex","onmessage","_e$data","data","result","algo","runAlgo","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","j","Object","keys","every","r","getter","__esModule","d","a","definition","o","defineProperty","enumerable","chunkId","Promise","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","p","b","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","next","then"],"sourceRoot":""}